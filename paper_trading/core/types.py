"""
Core unified types for the paper trading engine.

Provides a common type system that works across multiple strategy types,
bridging Pydantic-based strategies (volatility arbitrage) and DataFrame-based
strategies (signal mapping, options sentiment).
"""

from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Optional


class StrategyType(str, Enum):
    """
    Strategy classification types.

    Used to identify which strategy generated signals/positions
    for tracking and analysis purposes.
    """

    VOLATILITY_ARBITRAGE = "vol_arb"
    SIGNAL_MAPPING = "signal_mapping"
    OPTIONS_SENTIMENT = "options_sentiment"


@dataclass(frozen=True)
class Signal:
    """
    Universal signal format across all strategies.

    Represents a trading signal generated by any strategy,
    normalized to a common format for execution and tracking.

    Attributes:
        symbol: Instrument symbol (e.g., "SPY", "AAPL")
        action: Trade direction ("buy" or "sell")
        quantity: Number of contracts/shares to trade (must be positive)
        reason: Human-readable explanation for the signal
        strategy_type: Which strategy generated this signal
        timestamp: When the signal was generated
    """

    symbol: str
    action: str  # "buy" or "sell"
    quantity: int
    reason: str
    strategy_type: StrategyType
    timestamp: datetime

    def __post_init__(self) -> None:
        """Validate signal fields."""
        if self.quantity <= 0:
            raise ValueError(f"Quantity must be positive, got {self.quantity}")
        if self.action not in ["buy", "sell"]:
            raise ValueError(f"Action must be 'buy' or 'sell', got {self.action}")
        if not self.symbol:
            raise ValueError("Symbol cannot be empty")


@dataclass
class UnifiedPosition:
    """
    Multi-strategy position tracking.

    Tracks a single position that may have been opened by any strategy.
    Unlike the frozen Signal type, positions are mutable to allow updates
    as market prices change.

    Attributes:
        symbol: Instrument symbol
        quantity: Position size (positive for long, negative for short)
        avg_entry_price: Average entry price for the position
        current_price: Current market price
        strategy_type: Strategy that opened this position
        last_update: Last time the position was updated
    """

    symbol: str
    quantity: int
    avg_entry_price: Decimal
    current_price: Decimal
    strategy_type: StrategyType
    last_update: datetime

    @property
    def market_value(self) -> Decimal:
        """Calculate current market value of the position."""
        return Decimal(self.quantity) * self.current_price

    @property
    def cost_basis(self) -> Decimal:
        """Calculate original cost basis of the position."""
        return Decimal(abs(self.quantity)) * self.avg_entry_price

    @property
    def unrealized_pnl(self) -> Decimal:
        """Calculate unrealized profit/loss."""
        return (self.current_price - self.avg_entry_price) * Decimal(self.quantity)

    @property
    def unrealized_pnl_pct(self) -> Decimal:
        """Calculate unrealized P&L as a percentage of cost basis."""
        if self.cost_basis == 0:
            return Decimal("0")
        return (self.unrealized_pnl / self.cost_basis) * Decimal("100")

    def update_price(self, new_price: Decimal, timestamp: datetime) -> None:
        """
        Update current price and timestamp.

        Args:
            new_price: New market price
            timestamp: Time of the price update
        """
        self.current_price = new_price
        self.last_update = timestamp


@dataclass(frozen=True)
class Trade:
    """
    Executed trade record.

    Immutable record of a completed trade execution.
    Used for trade history, analytics, and reconciliation.

    Attributes:
        timestamp: Execution timestamp
        symbol: Instrument symbol
        action: "buy" or "sell"
        quantity: Number of contracts/shares traded
        price: Execution price
        commission: Trading commission paid
        strategy_type: Strategy that generated the trade
        signal_reason: Original signal reasoning (optional)
    """

    timestamp: datetime
    symbol: str
    action: str
    quantity: int
    price: Decimal
    commission: Decimal
    strategy_type: StrategyType
    signal_reason: Optional[str] = None

    @property
    def notional_value(self) -> Decimal:
        """Calculate total notional value (price * quantity)."""
        return self.price * Decimal(self.quantity)

    @property
    def total_cost(self) -> Decimal:
        """Calculate total cost including commission."""
        return self.notional_value + self.commission


@dataclass
class BacktestResult:
    """
    Backtesting results container.

    Aggregates all backtest outcomes including metrics, trades,
    and equity curve for analysis and comparison.

    Attributes:
        strategy_type: Strategy that was backtested
        start_date: Backtest start date
        end_date: Backtest end date
        initial_capital: Starting capital
        final_capital: Ending capital
        total_return: Absolute return (dollars)
        total_return_pct: Return as percentage
        sharpe_ratio: Risk-adjusted return (annualized)
        max_drawdown: Maximum peak-to-trough decline
        num_trades: Total number of trades
        num_winning_trades: Number of profitable trades
        num_losing_trades: Number of losing trades
        win_rate: Percentage of winning trades
        trades: List of executed trades
        equity_curve: DataFrame with timestamp, cash, positions_value, total_equity columns
    """

    strategy_type: StrategyType
    start_date: datetime
    end_date: datetime
    initial_capital: Decimal
    final_capital: Decimal
    total_return: Decimal
    total_return_pct: Decimal
    sharpe_ratio: Optional[Decimal]
    max_drawdown: Decimal
    num_trades: int
    num_winning_trades: int
    num_losing_trades: int
    win_rate: Decimal
    trades: list[Trade]
    equity_curve: object  # pd.DataFrame, but avoiding import here

    @property
    def profit_factor(self) -> Optional[Decimal]:
        """
        Calculate profit factor (gross profits / gross losses).

        Returns None if there are no losing trades.
        """
        if self.num_losing_trades == 0:
            return None

        gross_profits = sum(
            (t.price - Decimal("0")) * Decimal(t.quantity)
            for t in self.trades
            if t.action == "sell"
        )
        gross_losses = sum(
            (Decimal("0") - t.price) * Decimal(t.quantity)
            for t in self.trades
            if t.action == "buy"
        )

        if gross_losses == 0:
            return None

        return abs(gross_profits / gross_losses)
